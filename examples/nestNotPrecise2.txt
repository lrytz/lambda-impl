let boolEff: Bool =>[eff] Bool = (b: Bool) => b in

// this is the same as nestNotPrecise, but we make 'ho' effect-polymorphic instead
// this type-checks, however the effect of the main expression (ho (f: Nat => Nat) => f 1) is [top].
//
// the reson: while type-checking the application to 'ho'
//      ho (f: Nat => Nat) -> f 1
// we know that 'ho' will apply the argument to SOME function (Nat => Nat). but we
// don't know which, therefore we have to assume it can have effect "top".
//
// it can be fixed by setting the effect of the (Nat => Nat) function to pure.

let ho: ((Nat => Nat) -> Nat) -> Nat =
  (f: (Nat => Nat) -> Nat) -> ((g: Bool => Bool) => f) boolEff (x: Nat) => x in

ho (f: Nat => Nat) -> f 1
