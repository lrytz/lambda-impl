let ho: ((Nat =>[e] Nat) =>[bot] Nat -> Nat) =>[e] Nat =
  (f: (Nat =>[e] Nat) =>[bot] Nat -> Nat) => f ((x: Nat) => x) 0 in


let f1: (Nat =>[bot] Nat) =>[bot] Nat -> Nat =
  (f: Nat =>[bot] Nat) => (x: Nat) -> f x                        in

let f2: (Nat =>[e,k] Nat) =>[bot] Nat -> Nat =
  (f: Nat =>[e,k] Nat) => (x: Nat) -> f x                        in

let f3: (Nat =>[e] Nat) =>[bot] Nat -> Nat =
  (f: Nat =>[e] Nat) => (x: Nat) -> f x                          in


// - applying ho to f1 would be unsound. in the body of ho, we assume that f accepts a function with effect e
// - applying ho to f2 is OK:
//    - it accepts a function with a greater effect, so it is better
//    - since it's effect polymorphic, that greater effect only appears if something with a greater effect is
//      put in. but this cannot happen in ho - there only the small effect can be put in. so it's sound.
// - applying ho to f3 is obviously OK, it has the same type as the argument

ho f3
