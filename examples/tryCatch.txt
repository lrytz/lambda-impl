/*
for these examples:
 - we don't have (Unit => Nat), so we use (Bool => Nat)
 - we don't have exception types, so we use Nat as exception type

with current language
  let try: (Bool => Nat) =>[bot] (Nat => Nat) -> Nat = ... in

with dependent types: lexical masking
  let try: (Bool => Nat) 'body'=>[bot] (Nat => Nat) 'handler'->{(body \ throws) join handler} Nat = ... in

in scala
  def try(body: => Int, handler: Exception => Int): Int @mask(like(body), throws) @like(handler)



once we have try, can we write myTry?
  let myTry: (Bool => Nat) 'bd'=>[bot] (Nat => Nat) 'hn'->{(body \ throws) join handler} Nat =
    (bd: Bool => Nat) =>[bot] (hn: Nat => Nat) -> try bd hn
  
  the computed effect of "try bd hn" should be "(bd \ throws) join hd". so we need to keep the
  parameter names, replace the names
*/
